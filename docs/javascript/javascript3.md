## 异步流程

`异步流程`是指在程序中执行的一系列操作不是按照顺序同步执行的，而是按照事件发生或者异步操作的完成情况来执行的一种流程。这种方式允许程序在等待某些操作完成时继续执行其他任务，而不会被阻塞。异步流程在处理网络请求、文件读写、用户输入等需要等待的情况下非常有用。

以下是异步流程的一般步骤和一些常见的异步编程模式：

1. **发起异步操作**：首先，你会发起一个异步操作，比如发起一个网络请求、读取一个文件、等待用户输入等。这些操作可能需要一段时间来完成。
2. **注册回调函数**：一旦异步操作被触发，你通常会注册一个回调函数，这个函数将在操作完成后被调用。回调函数是异步流程中的关键，因为它定义了在异步操作完成时要执行的逻辑。
3. **继续执行**：在注册回调函数后，程序通常会继续执行其他任务，而不会等待异步操作完成。这样可以提高程序的响应性，不会让程序在等待 I/O 操作时被阻塞。
4. **异步操作完成**：当异步操作完成（比如网络请求返回数据、文件读取完成、用户输入就绪等），注册的回调函数将被调用，执行与异步操作相关的逻辑。

以下是一些常见的异步编程模式和技术：

- 1. **回调函数**：最基本的异步编程模式是使用回调函数。你将一个函数作为参数传递给异步操作，当操作完成时，回调函数将被执行。
- 2. **Promise**：Promise 是一种更高级的异步编程模式，它提供了一种更结构化的方式来处理异步操作。通过 Promise，你可以更容易地处理异步操作的成功和失败情况。
- 3. **async/await**：async/await 是 JavaScript 中的异步编程语法糖，它基于 Promise 构建，使异步代码看起来更像同步代码，提高了可读性。
- 4. **事件驱动编程**：在事件驱动编程中，将事件处理程序注册到特定事件上，当事件发生时，处理程序将被调用。这在前端开发和 Node.js 等环境中常见。
- 5. **生成器函数**：生成器函数允许你在迭代中暂停和恢复执行，这对于处理异步操作的结果很有用。

异步流程允许程序在执行过程中**非阻塞地处理多个任务**，提高了程序的效率和用户体验。然而，它也需要更复杂的控制流程，因此需要小心处理回调地狱和异步错误处理等问题。

## [微任务宏任务](/es6/promise2.md#事件循环-event-loop)

微任务（`Microtask`）和宏任务（`Macrotask`）是与事件循环（`Event Loop`）相关的两个重要概念，用于管理异步操作和任务执行的顺序。

**[微任务（Microtask）](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth)**：

- 1. 微任务是一种**异步任务**，它的执行顺序在宏任务之后，在每个事件循环迭代中**立即执行**。
- 2. 微任务通常比宏任务**更高优先级**，因此它们会在当前宏任务执行完毕后立即执行，而不会等待下一个宏任务。
- 3. 常见的微任务包括 Promise 的`then`和`catch`方法、`process.nextTick`（Node.js 中的微任务）等。
- 4. 微任务通常用于执行一些高优先级的任务，比如更新 UI，处理 Promise 的结果等。

**宏任务（Macrotask）**：

- 1. 宏任务是一种**异步任务**，它的执行顺序在微任务之后，通常在每个事件循环迭代中只执行一个。
- 2. 宏任务包括整体的 JavaScript 代码、`setTimeout`、`setInterval`、`requestAnimationFrame`（浏览器中的动画帧任务）、I/O 操作等。
- 3. 宏任务的执行顺序会等待当前的微任务队列执行完毕后，然后从宏任务队列中选择下一个宏任务执行。

> **任务没有优先级**，在`消息队列`中先进先出; 但**消息队列是有优先级的**<br/>
> 根据 W3C 的最新解释:<br/>
> 每个任务都有⼀个`任务类型`，同⼀个类型的任务必须在⼀个队列，不同类型 的任务可以分属于不同的队列。 在⼀次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。<br/>
> 浏览器必须准备好一个`微队列`，微队列中的任务优先所有任务执行。<br/>

随着浏览器的复杂度极具提升，**W3C 不再使用宏队列**的说法。
在目前的 chrome 的实现中，至少包含了下面的队列：

- `延时队列`：用于存放计时器到达的回调任务，优先级（中
- `交互队列`：用于存放用户操作后产生的事件处理任务，优先级（高
- `微队列`：用户存放需要最快执行的任务，优先级（最高

**总结**：
微任务和宏任务是**异步编程**中用于控制任务执行顺序的两个关键概念。微任务通常比宏任务具有**更高的优先级**，因此它们会在当前宏任务执行完毕后**立即执行**。了解它们的执行顺序对于理解事件循环和编写可预测的异步代码非常重要。在浏览器环境中，宏任务和微任务的常见示例包括 setTimeout、Promise、`MutationObserver`等。在 Node.js 环境中，宏任务和微任务的示例包括`setImmediate`、`process.nextTick`等。

## 类继承的方式,缺点

在面向对象编程中，**类继承**是一种重要的机制，它允许一个类（子类）继承另一个类（父类）的属性和方法。类继承可以通过不同的方式实现，其中最常见的方式有以下几种：

- 1. **单继承**：每个子类只能继承一个父类。这是一种简单且常见的继承方式，用于构建类层次结构。
- 2. **多继承**：一个子类可以继承多个父类的属性和方法。多继承在某些编程语言中支持，但容易引发复杂性和歧义，因此在一些语言中不被推荐或禁止使用。
- 3. **接口继承**：子类可以实现多个接口，从而继承接口中定义的方法签名，而不是具体实现。
- 4. **混入（Mixin）**：混入是一种通过将多个类的功能组合到一个类中来实现多继承的技术。它通常使用**组合**而非继承来实现复用。

不过，类继承也存在一些缺点和问题：

- 1. **紧耦合（Tight Coupling）**：类继承会在子类和父类之间创建紧耦合的关系，子类通常依赖于父类的内部实现细节。这可能导致代码的脆弱性，因为对父类的修改可能会影响到子类的行为。
- 2. **继承层次复杂性**：随着继承层次的增加，代码的复杂性也会增加，导致难以维护和理解。深层次的继承层次可能会导致"钻石问题"，即多个子类继承自同一个父类，而这些子类又被用于创建新的子类，形成一个钻石形状的继承层次。
- 3. **限制了代码重用**：类继承通常采用单一继承模式，这意味着子类只能从一个父类继承功能。这可能会限制代码的重用性，因为某个类可能需要继承多个不同的功能。
- 4. **不利于单元测试**：继承链中的每个类都可能有自己的状态和行为，这使得单元测试变得复杂，因为需要考虑多层继承中的各种情况和依赖关系。
- 5. **不够灵活**：继承是一种静态的关系，一旦定义了继承关系，就难以在运行时动态地改变。这可能限制了代码的灵活性和可扩展性。

为了克服这些缺点，一些编程语言和编程范式引入了其他方式来实现代码重用和抽象，如组合、接口、混入等。在选择使用类继承时，需要慎重考虑设计和维护的复杂性，以确保它适合特定的问题和场景。

**钻石问题**：比如说 b 和 c 都继承自 a，d 继承自 b 和 c，那么 d 里面就会有同一个方法来自于两个两个祖先，那么当在 d 中调用这个方法时就会出现逻辑问题，到底是调用 b 的呢还是 c 的呢？java 就是看到了 c++多继承的问题所以就干脆不允许多继承了，js 因为自身的灵活性，我们依然可以通过一些方式来实现多继承(很多地方叫做 mixin，实际上听起来更正确)。

## [promise,async await](/es6/promise2.md)

`Promise` 和 `async/await` 是 JavaScript 中用于处理异步操作的两种不同的机制，它们都旨在让异步代码更加可读和易于管理。

Promise：

- `Promise` **是一种更底层的异步处理机制，适用于处理单个异步操作**，它提供了一种更结构化的方式来处理异步操作。一个 Promise 表示一个异步操作的最终完成或失败，以及它的结果值或失败原因。
- `Promise` 有三个状态：`pending`（进行中）、`fulfilled`（已成功）、`rejected`（已失败）。一旦 Promise 进入 fulfilled 或 rejected 状态，它就**不会再改变状态**。
- `Promise` 使用 `.then()` 方法来注册回调函数，当异步操作成功时执行 then() 方法的第一个回调函数，当异步操作失败时执行第二个回调函数。
- `Promise` 链（Promise chaining）允许你按顺序执行一系列的异步操作，每个操作都**返回一个 Promise**，这样可以更好地控制异步代码的流程。

async/await：

- `Async/Await语法糖` 是**基于 Generator 函数的语法扩展**，它提供了一种更像同步代码的方式来处理异步操作。async 函数返回一个 `Promise`，这个 `promise` 要么会通过一个**由 async 函数返回的值被解决**，要么会通过一个从 async 函数中抛出的（或其中没有被捕获到的）异常被拒绝。`await` 表达式**会暂停整个 async 函数的执行进程并出让其控制权**，只有当其等待的基于 `promise` 的异步操作被兑现或被拒绝之后才会恢复进程。`promise` 的解决值会被当作该 await 表达式的返回值
- `async` 函数内部可以使用 await 关键字来等待异步操作的结果，这样可以在代码中像编写同步代码一样使用异步操作。
- `async` 函数的执行会在遇到第一个 `await` 表达式时暂停，然后等待该表达式的 Promise 解决。之后，async 函数会继续执行，直到遇到下一个 await 表达式或函数结束。

## es6 模块化

ES6（ECMAScript 2015）模块化是 JavaScript 中一种用于组织和管理代码的现代模块系统。它使得代码模块化、可重用、可维护，并允许你将代码拆分成多个文件，以便更好地管理复杂性和依赖关系。下面是 ES6 模块化的一些关键特点和用法：

1. 导出模块成员（Export）：<br/>
   使用 `export` 关键字可以将变量、函数、类等从一个模块导出，使其在其他模块中可用。可以导出多个成员，并且可以使用命名导出和默认导出两种方式。

```js
// 导出单个成员（命名导出）
export const name = "John";
// 导出多个成员（命名导出）
export function greet() {
  return "Hello, world!";
}
// 默认导出
export default function () {
  console.log("Default export");
}
```

2. 导入模块成员（Import）：<br/>
   使用 `import` 关键字可以在其他模块中导入已经导出的成员。可以使用具名导入和默认导入两种方式。

```js
// 导入单个成员（具名导入）
import { name, greet } from "./module";
// 导入默认成员（默认导入）
import defaultFunction from "./module";
```

3. 模块之间的依赖关系：<br/>
   模块可以明确指定它们之间的**依赖关系**。如果一个模块依赖于另一个模块，当导入的模块发生变化时，导入的模块会自动重新加载。
4. 模块的执行顺序：<br/>
   模块的**执行顺序是静态的**，它们在运行时只会加载一次。这有助于避免全局污染和循环依赖问题。
5. 循环依赖：<br/>
   尽量避免模块之间的循环依赖，这可能导致难以理解的行为。
6. 模块化加载：<br/>
   在浏览器中，可以使用 `<script type="module">` 标签来加载 ES6 模块，或者使用工具（如`Webpack、Rollup`）将模块打包为一个文件，然后在浏览器中引入打包后的文件。

ES6 模块化提供了一种现代、可维护和可重用的方式来组织 JavaScript 代码，它已经成为了前端开发和 Node.js 开发中的标准实践。它有助于减少全局命名空间污染、提高代码可维护性、更好地管理依赖关系等。
