# browser 的理解

## 一、缓存

**强缓存**（不需要发送 `HTTP` 请求）

1. `Expires` （过期时间）存在于响应头中。
2. `Cache-Control`（存在与请求头和响应头中）

- max-age
- public
- private
- no-cache
- no-store
- s-maxage

### 协商缓存（需要发送 HTTP 请求，在请求头中携带缓存 tag，在服务器端决定是否使用缓存）

1. `Last-Modified` （浏览器第二次发送请求会在请求头中携带：If-Modified-Since）304：用户直接使用缓存
2. `ETag` 文件生成的唯一标识（浏览器第二次发送请求会在请求头中携带：If-None-Match）304：用户直接使用缓存

### 缓存地址：

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache

## 二、浏览器本地存储

浏览器本地存储：

1. `Cookie`
2. `WebStorage`（localStorage、sessionStorage）
3. `IndexDB`

## 三、从输入 URL 到页面呈现发生了什么？

### 网络请求和响应：

1. 构建请求行 GET / HTTP/1.1，同时带上请求头和请求体
2. 查找强缓存
3. `DNS` 解析
4. `TCP` 连接
5. 网络响应

- 响应行：HTTP/1.1 200 OK
- 响应头：Set-Cookie、Date、Server、Cache-Control、Connection、Content-Encoding
- 响应体

```js
Content-Type: text/html
```

### 解析算法：

1. 构建 `DOM` 树 生成方便操作的数据结构
2. 样式计算 `CSS` 文本->结构化对象（styleSheets）

- 标准化样式属性
- 计算每个节点的样式 继承、层叠

3. 生成布局树 `DOM` 树+`DOM` 样式 -> 布局树（确定元素的位置）

### 渲染过程：

1. 建立图层树 解决复杂场景：3D 动画呈现的变换效果、元素含有层叠上下文时如何控制显示和隐藏等
   - 节点的图层默认属于父节点的图层（合称为合成层）
   - 合称方法：显式合称和隐式合成
   - 显示合称： 1. 层叠上下文 2. 需要裁剪的地方
2. 生成绘制列表
3. 生成图块并删格化
4. 显示器显示内容

## 四、 回流和重绘

### 回流

触发条件：

- width、height、padding、margin、left、right、border
- 节点增删
- 读写 offset、scroll、client
- 调用 window.getComputedStyle
  需要重新生成 DOM 树，解析和合成全部需要重新走一遍

### 重绘（repain）：

**window.requestAnimationFrame**

触发条件：样式发生变化，并没有影响几何属性

跳过了生成布局树和建图层树的过程。

## 五、 XSS

跨站脚本，浏览器中执行恶意脚本

- 存储型（存储到了服务器的数据库上）
- 反射性（作为网络请求的一部分）
- 文档型（并不会经过服务器，在数据传输过程劫持到网络数据包，然后修改里面的 HTML 文档）

### 防范措施：

1. 对用户输入进行转码、过滤
2. 利用 CSP（浏览器内容安全策略，服务器决定加载哪些功能）
   - 限制其他域下的资源加载
   - 禁止向其它域提交数据
3. 利用 HttpOnly

## 五、 CSRF

CSRF：跨站请求伪造

### 方式：

诱导用户点击链接，打开黑客的网站，利用用户目前的登录状态发起跨站请求。

1. 自动发起 GET 请求。 `<img src="xxx.com?user=aaa">`
2. 自动发起 POST 请求。
3. 诱导点击发送 GET 请求。

### 防范策略：

1. 利用 `Cookie` 的 SameSit 属性。

- Strict。完全禁止第三方携带 Cookie
- Lax。GET 请求可以。
- None。不限制

2. 验证来源站点。 请求头：**Origin**和**Referer**。
3. `CSRF Token`。

- 浏览器发送请求时，服务器生成字符串将其植入返回的页面中。

## 六、 HTTPS

HTTP 是**明文传输**，HTTP 数据 -> TCP 层 -> WIFI 路由器 -> 运营商 -> 服务器，中间过程可能被中间人攻击。

HTTPS 在 HTTP 和 TCP 之间建立了一个**安全层**，将数据**加密**之后传给 TCP，TCP 也必须将数据**解密**，才能传给上面的 HTTP。

安全层的核心就是对数据加解密。

1. 对称加密。加密和解密用的相同密钥。

- 浏览器 -> 服务器： client_random + 加密方法列表
- 服务器 -> 浏览器： server_random + 加密方法
- 用加密方法把这两个随机数混合起来，作为**暗号**
  因为用的相同密钥，这个加密方法既能加密也能解密拿到数据。

2. 非对称加密。有 A、B 两把密钥，A 可以解 B，B 也可以解 A。服务器有两把钥匙：公钥和密钥。

- 浏览器 -> 服务器： client_random + 加密方法列表
- 服务器 -> 浏览器： server_random + 加密方法 + 公钥
- 浏览器对用公钥对 clien_random 和 server_random 进行加密，生成通信**暗号**。
  中间人拿到浏览器的数据，因为没有私钥，无法解密，保证了数据安全。
  但相应的问题是：服务器 -> 浏览器数据，只能用私钥加密，中间人拿到公钥，就能进行解密了。

3. 非对称 + 对称结合。

- 浏览器 -> 服务器： client_random + 加密方法列表
- 服务器 -> 浏览器： server_random + 加密方法 + 公钥
- 浏览器生成随机数**pre_random**，并用公钥加密，传给服务器。
- 服务器用私钥解密，得到**pre_random**
- 然后浏览器和服务器用一样的公钥进行通信，即对称加密。
  中间人没有私钥，拿不到**pre_random**，无法生成最终的密钥。

### 添加数字证书

目的： 让服务器证明自己的身份。

向 CA 认证，会给服务器颁发数字证书。

作用：

1. 服务器向浏览器证明自己的身份
2. 把公钥传给服务器（数字证书包含了公钥）

读取证书中的明文内容，CA 会保存一个 Hash 函数，这个函数计算明文得到信息 A，公钥解密明文得到信息 B，两份信息对比一致认证合法。
