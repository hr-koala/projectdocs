# 面试官：说说地址栏输入 URL 敲下回车后发生了什么?

![址栏输入 URL](https://static.vue-js.com/11bf1f20-bdf4-11eb-85f6-6fac77c0c9b3.png)

## 一、简单分析

从前端的角度分析，从输入 `URL`到回车后发生的行为如下：

- URL 解析
- DNS 查询
- TCP 连接
- HTTP 请求
- 响应请求
- 页面渲染

## 二、详细分析

### URL 解析

首先判断你输入的是一个合法的` URL` 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作

`URL`的解析第过程中的第一步，一个`url`的结构解析如下：

![](https://static.vue-js.com/27a0c690-bdf4-11eb-ab90-d9ae814b240d.png)

### DNS 查询

将域名解析成 `IP` 地址

整个查询过程如下图所示：

![](https://static.vue-js.com/330fb770-bdf4-11eb-85f6-6fac77c0c9b3.png)

最终，获取到了域名对应的目标服务器`IP`地址

### TCP 连接

在之前文章中，了解到`tcp`是一种面向有连接的传输层协议

在确定目标服务器服务器的`IP`地址后，则经历三次握手建立`TCP`连接，流程如下：

![](https://static.vue-js.com/ad750790-bdf4-11eb-85f6-6fac77c0c9b3.png)

### 发送 http 请求

当建立`tcp`连接之后，就可以在这基础上进行通信，浏览器发送 `http` 请求到目标服务器

请求的内容包括：

- 请求行
- 请求头
- 请求主体

![](https://static.vue-js.com/bbcb60f0-bdf4-11eb-ab90-d9ae814b240d.png)

### 响应请求

当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个`HTTP`响应消息，包括：

- 状态行
- 响应头
- 响应正文

![响应请求](https://static.vue-js.com/c5fe0140-bdf4-11eb-ab90-d9ae814b240d.png)

在服务器响应之后，由于现在`http`默认开始长连接`keep-alive`，当页面关闭之后，`tcp`链接则会经过四次挥手完成断开

### 页面渲染

当浏览器接收到服务器响应的资源后，首先会对资源进行解析：

- 查看响应头的信息，根据不同的指示做对应处理，比如**重定向**，存储 `cookie`，**解压 gzip**，**缓存资源**等等
- 查看响应头的 `Content-Type` 的值，根据不同的资源类型采用不同的解析方式

关于页面的渲染过程如下：

浏览器接收到首屏 html，开始渲染

- 解析 `HTML`，构建 `DOM` 树
- 解析 `CSS` ，生成 `CSS` 规则树
- 合并 `DOM` 树和 `CSS` 规则，生成 `render` 树
- 布局 `render` 树（ `Layout` / `reflow` ），负责各元素尺寸、位置的计算
- 绘制 `render` 树（ `paint` ），绘制页面像素信息
- 浏览器会将各层的信息发送给 `GPU`，`GPU` 会将各层合成（ `composite` ），显示在屏幕上

![页面渲染](https://static.vue-js.com/db7bddd0-bdf4-11eb-85f6-6fac77c0c9b3.png)

从上面步骤可以看出，影响性能的主要是`加载`和`渲染`。此外还有运行时的性能：`脚本执行`。

## 加载优化

资源加载（网络层面）方面的性能优化主要是 **_减小资源体积，减少请求数量_**

### 减小资源体积

减小资源体积最有效的方法就是压缩。比如 js 混淆压缩，html 压缩，图片压缩等。再加上 Gzip 神器，再压缩三分之一以上不是问题

- 实际项目中体积大的基本上是图片，字体这些资源，代码体积反而没那么大
  - 注意 **_图片格式_**，png 格式无损压缩
  - **字体的优化**，在一些场景下，可以直接抽出需要的字体，文件立马小很多
  - **_按需加载_**，在组件库、babel-polyfill 等场景应用比较多

### 减少请求数量

减少请求数量，常用的方法就是 **_缓存_**和 **_合并请求_**

- 效果最顶的就是**浏览器缓存**。通过 `expires` 和 `Cache-Control` 进行**强缓存**；通过 `Last-Modified` 和 `ETag` 进行**协商缓存**，就能缓存大部分资源文件。基本上就剩文档（html）和接口的请求了。
- 第二种缓存是 `CDN`。`CDN` 是一组分布在各个地区的服务器，它们会缓存资源副本。用户发起请求时，哪个服务器近就由其响应请求。一般存放不需要服务端进行计算，且具有访问频率高，承载流量大的资源，如图片，脚本，样式文件等静态资源。
- 合并请求的方案就比较多了。如针对小图标的 `CSS sprite`、`base64`、`iconfont` 等；通过 `webpack` 等工具将 `js`、`css` **打包**成一个文件。但请求不是越少越好，一个大请求的速度不一定快过几个小请求，浏览器能同时发起几个请求，要充分利用这一特点。
- 减少请求数量还有 **_懒加载_** 和 **_预加载_** 的方法。**懒加载** 可以减少首屏的请求数量，如 `import()`。预加载则可以提高后续的用户体验，如预解析 `dns-prefetch`，预拉取 `prefetch`，图片预加载等。**_懒加载和预加载并不冲突_**，可以理解为不是马上需要的内容可以懒加载，即将需要的内容可以在浏览器空闲的时候预先加载。

### 渲染优化

- 提到渲染优化就不得不提 **回流和重绘**。批量操作 `DOM`，动画脱离文档流，`requestAnimationFrame` 这些方法就不多说了，容易忽略的是获取 `offsetLeft`， `offsetTop` 等值的时候也可能引起回流。由于回流成本太高，**_浏览器会将回流操作用队列存储_**，当过一段时间或达到某个阈值时清空队列，执行一次回流。但当获取有些值时，浏览器会提前触发回流，以确保获取的值是正确的。
- 其次是**_非阻塞_**。js 文件放 body 底部；`<script>` 标签的 `async` 和 `defer` 属性也是大家熟悉的。
- 除此之外，还有针对首屏渲染优化的 **_服务端渲染 SSR_**，优化首屏体验的 **_骨架屏_** 方案，针对长列表优化的**虚拟列表**等

### js 代码

代码层面的优化可以说道的很多，但实际上对性能影响很小，可以说是积少成多。除非写出天怒人怨的代码。以下举几个例子：

- 保存深层变量
- 使用 `===` 而非`==`，避免类型转换带来的性能损耗
- 少用 `for-in`
- 使用 `if-else`、`switch` 时，将最可能出现的情况放到前面
- 当条件大于（等于）3 个时，使用 `switch`。而当要判断的离散值数量很大时，使用对象或数据实现查表法
- 尾递归
- 避免改变词法作用域（如 `eval`，`with`）
- 减少操作 `DOM`
- 事件委托
- 删除 `DOM` 节点时，移除其绑定的事件
- 用 JS 实现动画时，应使用 `requestAnimationFrame`
- 防抖和节流
- `web worker`

  在使用框架时，还有针对框架的优化。如 Vue 中 `v-for` 循环 `key` 的绑定，`Object.freeze` 取消不会变更的数据的监听，切分成更小的组件以缩小更新的范围等。以及 React 中 `useMemo`，`useCallback` 等缓存钩子的使用

## 参考文献

- [https://github.com/febobo/web-interview/issues/141](https://github.com/febobo/web-interview/issues/141)
- [https://zhuanlan.zhihu.com/p/80551769](https://zhuanlan.zhihu.com/p/80551769)
