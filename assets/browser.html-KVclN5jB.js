import{_ as i,o as e,c as l,e as a}from"./app-lzSeYDl-.js";const r={},o=a(`<h1 id="browser-的理解" tabindex="-1"><a class="header-anchor" href="#browser-的理解" aria-hidden="true">#</a> browser 的理解</h1><h2 id="一、缓存" tabindex="-1"><a class="header-anchor" href="#一、缓存" aria-hidden="true">#</a> 一、缓存</h2><p><strong>强缓存</strong>（不需要发送 <code>HTTP</code> 请求）</p><ol><li><code>Expires</code> （过期时间）存在于响应头中。</li><li><code>Cache-Control</code>（存在与请求头和响应头中）</li></ol><ul><li>max-age</li><li>public</li><li>private</li><li>no-cache</li><li>no-store</li><li>s-maxage</li></ul><h3 id="协商缓存-需要发送-http-请求-在请求头中携带缓存-tag-在服务器端决定是否使用缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存-需要发送-http-请求-在请求头中携带缓存-tag-在服务器端决定是否使用缓存" aria-hidden="true">#</a> 协商缓存（需要发送 HTTP 请求，在请求头中携带缓存 tag，在服务器端决定是否使用缓存）</h3><ol><li><code>Last-Modified</code> （浏览器第二次发送请求会在请求头中携带：If-Modified-Since）304：用户直接使用缓存</li><li><code>ETag</code> 文件生成的唯一标识（浏览器第二次发送请求会在请求头中携带：If-None-Match）304：用户直接使用缓存</li></ol><h3 id="缓存地址" tabindex="-1"><a class="header-anchor" href="#缓存地址" aria-hidden="true">#</a> 缓存地址：</h3><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ol><h2 id="二、浏览器本地存储" tabindex="-1"><a class="header-anchor" href="#二、浏览器本地存储" aria-hidden="true">#</a> 二、浏览器本地存储</h2><p>浏览器本地存储：</p><ol><li><code>Cookie</code></li><li><code>WebStorage</code>（localStorage、sessionStorage）</li><li><code>IndexDB</code></li></ol><h2 id="三、从输入-url-到页面呈现发生了什么" tabindex="-1"><a class="header-anchor" href="#三、从输入-url-到页面呈现发生了什么" aria-hidden="true">#</a> 三、从输入 URL 到页面呈现发生了什么？</h2><h3 id="网络请求和响应" tabindex="-1"><a class="header-anchor" href="#网络请求和响应" aria-hidden="true">#</a> 网络请求和响应：</h3><ol><li>构建请求行 GET / HTTP/1.1，同时带上请求头和请求体</li><li>查找强缓存</li><li><code>DNS</code> 解析</li><li><code>TCP</code> 连接</li><li>网络响应</li></ol><ul><li>响应行：HTTP/1.1 200 OK</li><li>响应头：Set-Cookie、Date、Server、Cache-Control、Connection、Content-Encoding</li><li>响应体</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="解析算法" tabindex="-1"><a class="header-anchor" href="#解析算法" aria-hidden="true">#</a> 解析算法：</h3><ol><li>构建 <code>DOM</code> 树 生成方便操作的数据结构</li><li>样式计算 <code>CSS</code> 文本-&gt;结构化对象（styleSheets）</li></ol><ul><li>标准化样式属性</li><li>计算每个节点的样式 继承、层叠</li></ul><ol start="3"><li>生成布局树 <code>DOM</code> 树+<code>DOM</code> 样式 -&gt; 布局树（确定元素的位置）</li></ol><h3 id="渲染过程" tabindex="-1"><a class="header-anchor" href="#渲染过程" aria-hidden="true">#</a> 渲染过程：</h3><ol><li>建立图层树 解决复杂场景：3D 动画呈现的变换效果、元素含有层叠上下文时如何控制显示和隐藏等 <ul><li>节点的图层默认属于父节点的图层（合称为合成层）</li><li>合称方法：显式合称和隐式合成</li><li>显示合称： 1. 层叠上下文 2. 需要裁剪的地方</li></ul></li><li>生成绘制列表</li><li>生成图块并删格化</li><li>显示器显示内容</li></ol><h2 id="四、-回流和重绘" tabindex="-1"><a class="header-anchor" href="#四、-回流和重绘" aria-hidden="true">#</a> 四、 回流和重绘</h2><h3 id="回流" tabindex="-1"><a class="header-anchor" href="#回流" aria-hidden="true">#</a> 回流</h3><p>触发条件：</p><ul><li>width、height、padding、margin、left、right、border</li><li>节点增删</li><li>读写 offset、scroll、client</li><li>调用 window.getComputedStyle 需要重新生成 DOM 树，解析和合成全部需要重新走一遍</li></ul><h3 id="重绘-repain" tabindex="-1"><a class="header-anchor" href="#重绘-repain" aria-hidden="true">#</a> 重绘（repain）：</h3><p><strong>window.requestAnimationFrame</strong></p><p>触发条件：样式发生变化，并没有影响几何属性</p><p>跳过了生成布局树和建图层树的过程。</p><h2 id="五、-xss" tabindex="-1"><a class="header-anchor" href="#五、-xss" aria-hidden="true">#</a> 五、 XSS</h2><p>跨站脚本，浏览器中执行恶意脚本</p><ul><li>存储型（存储到了服务器的数据库上）</li><li>反射性（作为网络请求的一部分）</li><li>文档型（并不会经过服务器，在数据传输过程劫持到网络数据包，然后修改里面的 HTML 文档）</li></ul><h3 id="防范措施" tabindex="-1"><a class="header-anchor" href="#防范措施" aria-hidden="true">#</a> 防范措施：</h3><ol><li>对用户输入进行转码、过滤</li><li>利用 CSP（浏览器内容安全策略，服务器决定加载哪些功能） <ul><li>限制其他域下的资源加载</li><li>禁止向其它域提交数据</li></ul></li><li>利用 HttpOnly</li></ol><h2 id="五、-csrf" tabindex="-1"><a class="header-anchor" href="#五、-csrf" aria-hidden="true">#</a> 五、 CSRF</h2><p>CSRF：跨站请求伪造</p><h3 id="方式" tabindex="-1"><a class="header-anchor" href="#方式" aria-hidden="true">#</a> 方式：</h3><p>诱导用户点击链接，打开黑客的网站，利用用户目前的登录状态发起跨站请求。</p><ol><li>自动发起 GET 请求。 <code>&lt;img src=&quot;xxx.com?user=aaa&quot;&gt;</code></li><li>自动发起 POST 请求。</li><li>诱导点击发送 GET 请求。</li></ol><h3 id="防范策略" tabindex="-1"><a class="header-anchor" href="#防范策略" aria-hidden="true">#</a> 防范策略：</h3><ol><li>利用 <code>Cookie</code> 的 SameSit 属性。</li></ol><ul><li>Strict。完全禁止第三方携带 Cookie</li><li>Lax。GET 请求可以。</li><li>None。不限制</li></ul><ol start="2"><li>验证来源站点。 请求头：<strong>Origin</strong>和<strong>Referer</strong>。</li><li><code>CSRF Token</code>。</li></ol><ul><li>浏览器发送请求时，服务器生成字符串将其植入返回的页面中。</li></ul><h2 id="六、-https" tabindex="-1"><a class="header-anchor" href="#六、-https" aria-hidden="true">#</a> 六、 HTTPS</h2><p>HTTP 是<strong>明文传输</strong>，HTTP 数据 -&gt; TCP 层 -&gt; WIFI 路由器 -&gt; 运营商 -&gt; 服务器，中间过程可能被中间人攻击。</p><p>HTTPS 在 HTTP 和 TCP 之间建立了一个<strong>安全层</strong>，将数据<strong>加密</strong>之后传给 TCP，TCP 也必须将数据<strong>解密</strong>，才能传给上面的 HTTP。</p><p>安全层的核心就是对数据加解密。</p><ol><li>对称加密。加密和解密用的相同密钥。</li></ol><ul><li>浏览器 -&gt; 服务器： client_random + 加密方法列表</li><li>服务器 -&gt; 浏览器： server_random + 加密方法</li><li>用加密方法把这两个随机数混合起来，作为<strong>暗号</strong> 因为用的相同密钥，这个加密方法既能加密也能解密拿到数据。</li></ul><ol start="2"><li>非对称加密。有 A、B 两把密钥，A 可以解 B，B 也可以解 A。服务器有两把钥匙：公钥和密钥。</li></ol><ul><li>浏览器 -&gt; 服务器： client_random + 加密方法列表</li><li>服务器 -&gt; 浏览器： server_random + 加密方法 + 公钥</li><li>浏览器对用公钥对 clien_random 和 server_random 进行加密，生成通信<strong>暗号</strong>。 中间人拿到浏览器的数据，因为没有私钥，无法解密，保证了数据安全。 但相应的问题是：服务器 -&gt; 浏览器数据，只能用私钥加密，中间人拿到公钥，就能进行解密了。</li></ul><ol start="3"><li>非对称 + 对称结合。</li></ol><ul><li>浏览器 -&gt; 服务器： client_random + 加密方法列表</li><li>服务器 -&gt; 浏览器： server_random + 加密方法 + 公钥</li><li>浏览器生成随机数<strong>pre_random</strong>，并用公钥加密，传给服务器。</li><li>服务器用私钥解密，得到<strong>pre_random</strong></li><li>然后浏览器和服务器用一样的公钥进行通信，即对称加密。 中间人没有私钥，拿不到<strong>pre_random</strong>，无法生成最终的密钥。</li></ul><h3 id="添加数字证书" tabindex="-1"><a class="header-anchor" href="#添加数字证书" aria-hidden="true">#</a> 添加数字证书</h3><p>目的： 让服务器证明自己的身份。</p><p>向 CA 认证，会给服务器颁发数字证书。</p><p>作用：</p><ol><li>服务器向浏览器证明自己的身份</li><li>把公钥传给服务器（数字证书包含了公钥）</li></ol><p>读取证书中的明文内容，CA 会保存一个 Hash 函数，这个函数计算明文得到信息 A，公钥解密明文得到信息 B，两份信息对比一致认证合法。</p>`,62),d=[o];function t(n,s){return e(),l("div",null,d)}const c=i(r,[["render",t],["__file","browser.html.vue"]]);export{c as default};
