import{_ as a,o as e,c as n,e as s}from"./app-lzSeYDl-.js";const t={},r=s(`<h2 id="说说-var、let、const-之间的区别" tabindex="-1"><a class="header-anchor" href="#说说-var、let、const-之间的区别" aria-hidden="true">#</a> 说说 var、let、const 之间的区别</h2><p><code>var</code>、<code>let</code>、<code>const</code> 三者区别可以围绕下面五点展开：</p><ul><li>变量提升</li><li>暂时性死区</li><li>块级作用域</li><li>重复声明</li><li>修改声明的变量</li><li>使用</li></ul><h3 id="变量提升" tabindex="-1"><a class="header-anchor" href="#变量提升" aria-hidden="true">#</a> 变量提升</h3><p>在 ES5 中，顶层对象的属性和全局变量是等价的，用 var 声明的变量既是全局变量，也是顶层变量<br> 注意：顶层对象，在浏览器环境指的是 <code>window</code> 对象，在 Node 指的是 <code>global</code> 对象<br> var 声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined<br> let 和 const 不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错<br> let 命令所在的代码块内有效</p><h3 id="暂时性死区" tabindex="-1"><a class="header-anchor" href="#暂时性死区" aria-hidden="true">#</a> 暂时性死区</h3><p>var 不存在暂时性死区<br> let 和 const 存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量 只要块级作用域内存在 let 命令，这个区域就不再受外部影响</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
  <span class="token keyword">let</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><div class="highlight-line"> </div><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="块级作用域" tabindex="-1"><a class="header-anchor" href="#块级作用域" aria-hidden="true">#</a> 块级作用域</h3><p>var 不存在块级作用域<br> let 和 const 存在块级作用域</p><h3 id="重复声明" tabindex="-1"><a class="header-anchor" href="#重复声明" aria-hidden="true">#</a> 重复声明</h3><p>var 允许重复声明变量<br> let 和 const 在同一作用域不允许重复声明变量</p><h3 id="修改声明的变量" tabindex="-1"><a class="header-anchor" href="#修改声明的变量" aria-hidden="true">#</a> 修改声明的变量</h3><p>var 和 let 可以<br> const 声明一个只读的常量。一旦声明，常量的值就不能改变<br> const 实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动<br> 对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量<br> 对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的，并不能确保改变量的结构不变</p><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h3><p>能用 const 的情况尽量使用 const，其他情况下大多数使用 let，避免使用 var</p>`,16),c=[r];function i(o,l){return e(),n("div",null,c)}const p=a(t,[["render",i],["__file","let_const.html.vue"]]);export{p as default};
