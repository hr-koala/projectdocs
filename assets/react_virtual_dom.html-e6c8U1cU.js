import{_ as n,o as a,c as s,e}from"./app-lzSeYDl-.js";const t="/images/react/react8.jpg",o="/images/react/react9.jpg",c={},p=e('<h1 id="虚拟-dom" tabindex="-1"><a class="header-anchor" href="#虚拟-dom" aria-hidden="true">#</a> 虚拟 DOM</h1><h2 id="_1-对虚拟-dom-的理解-虚拟-dom-主要做了什么-虚拟-dom-本身是什么" tabindex="-1"><a class="header-anchor" href="#_1-对虚拟-dom-的理解-虚拟-dom-主要做了什么-虚拟-dom-本身是什么" aria-hidden="true">#</a> 1. 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？</h2><p>从本质上来说，<code>Virtual Dom</code>是一个<code>JavaScript对象</code>，通过对象的方式来表示 <code>DOM</code> 结构。将页面的状态抽象为<code>JS对象</code>的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过<code>事务处理机制</code>，将多次 DOM 修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改 <code>DOM</code> 的重绘重排次数，提高渲染性能。</p><p><code>虚拟DOM</code>是对 DOM 的抽象，这个对象是更加轻量级的对 DOM 的描述。它设计的最初目的，就是更好的跨平台，比如 node.js 就没有 DOM，如果想实现 SSR，那么一个方式就是借助虚拟 dom，因为虚拟 dom 本身是 js 对象。 在代码渲染到页面之前，vue 或者 react 会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实 dom 结构，最终渲染到页面。 在每次数据发生变化前，虚拟 dom 都会缓存一份，变化之时，现在的虚拟 dom 会与缓存的虚拟 dom 进行比较。在 vue 或者 react 内部封装了<code>diff算法</code>，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p><p>另外现代前端框架的一个基本要求就是<code>无须手动操作DOM</code>，一方面是因为手动操作 DOM 无法保证程序性能，多人协作的项目中如果 review 不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动 DOM 操作可以大大提高开发效率。</p><p><strong>为什么要用 Virtual DOM</strong>：</p><p>（1）<strong>保证性能下限</strong>，在不进行手动优化的情况下，提供过得去的性能</p><p>下面对比一下修改 DOM 时真实 DOM 操作和 Virtual DOM 的过程，来看一下它们重排重绘的性能消耗 ∶</p><ul><li>真实 DOM∶ 生成 HTML 字符串＋ 重建所有的 DOM 元素</li><li>Virtual DOM∶ 生成 vNode ＋ DOMDiff ＋必要的 DOM 更新 Virtual DOM 的更新 DOM 的准备工作耗费更多的时间，也就是<code>JS层面</code>，相比于更多的 DOM 操作它的消费是极其便宜的。尤雨溪在社区论坛中说道 ∶ 框架给你的保证是，你不需要手动优化的情况下，我依然可以给你提供过得去的性能。</li></ul><p>（2）<strong>跨平台</strong></p><p>Virtual DOM 本质上是<code>JavaScript的对象</code>，它可以很方便的跨平台操作，比如服务端渲染、uniapp 等。</p><h2 id="_2-react-diff-算法的原理是什么" tabindex="-1"><a class="header-anchor" href="#_2-react-diff-算法的原理是什么" aria-hidden="true">#</a> 2. React diff 算法的原理是什么？</h2><p>实际上，<code>diff 算法</code>探讨的就是虚拟 DOM 树发生变化后，<code>生成 DOM 树更新补丁</code>的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新。 <img src="'+t+'" alt="React diff"></p><p>具体的流程如下：</p><ul><li>真实的 <code>DOM</code> 首先会<strong>映射</strong>为虚拟 DOM；</li><li>当虚拟 DOM 发生变化后，就会根据差距计算生成 <code>patch</code>，这个 <code>patch</code> 是一个结构化的数据，内容包含了增加、更新、移除等；</li><li>根据 <code>patch</code> 去更新真实的 DOM，反馈到用户的界面上。 <img src="'+o+`" alt="React diff"></li></ul><p>一个简单的例子：</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>isVisible<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>visible<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">visbile</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>hidden<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">hidden</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，首先假定 <code>ExampleComponent</code> 可见，然后再改变它的状态，让它不可见 。映射为真实的 DOM 操作是这样的，React 会创建一个 div 节点。</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>visible<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">visbile</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当把 visbile 的值变为 false 时，就会替换 class 属性为 hidden，并重写内部的 innerText 为 hidden。这样一个<strong>生成补丁、更新差异的过程统称为 diff 算法</strong>。</p><p>diff 算法可以总结为三个策略，分别从<code>树、组件及元素</code>三个层面进行复杂度的优化：</p><ul><li>策略一：<strong>忽略节点跨层级操作</strong>场景，提升比对效率。（<strong>基于树进行对比</strong>）<br> 这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。</li><li>策略二：如果组件的 <code>class</code> 一致，则默认为相似的树结构，否则默认为不同的树结构。（<strong>基于组件进行对比</strong>）<br> 在组件比对的过程中： <ul><li>如果组件是同一类型则进行树比对；</li><li>如果不是则直接放入补丁中。只要父组件类型不同，就会被重新渲染。<br> 这也就是为什么 <code>shouldComponentUpdate</code>、<code>PureComponent</code> 及<code>React.memo</code> 可以提高性能的原因。</li></ul></li><li>策略三：同一层级的子节点，可以通过<strong>标记 key</strong> 的方式进行列表对比。（<strong>基于节点进行对比</strong>）<br> 元素比对主要发生在同层级中，通过<strong>标记节点</strong>操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。</li></ul><h2 id="_3-react-key-干嘛用的-为什么要加-key-主要是解决哪一类问题" tabindex="-1"><a class="header-anchor" href="#_3-react-key-干嘛用的-为什么要加-key-主要是解决哪一类问题" aria-hidden="true">#</a> 3. React key 干嘛用的 为什么要加？key 主要是解决哪一类问题</h2><p><code>Keys</code> 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的<strong>辅助标识</strong>。 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有<strong>唯一性</strong>。</p><p>在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染 此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系。</p><p>注意事项：<br></p><ul><li><code>key</code> 值一定要和具体的元素—一对应；</li><li>尽量不要用数组的 <code>index</code> 去作为 key；</li><li>不要在 <code>render</code> 的时候用随机数或者其他操作给元素加上不稳定的 key，这样造成的性能开销比不加 key 的情 况下更糟糕。</li></ul><h2 id="_4-虚拟-dom-的引入与直接操作原生-dom-相比-哪一个效率更高-为什么" tabindex="-1"><a class="header-anchor" href="#_4-虚拟-dom-的引入与直接操作原生-dom-相比-哪一个效率更高-为什么" aria-hidden="true">#</a> 4. 虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么</h2><p><code>虚拟 DOM</code> 相对<code>原生的 DOM</code> 不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 DOM 的操作无论如何都不可能比真实的 DOM 操作更快。 在首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，虚拟 DOM 也会比 innerHTML 插入慢。<strong>它能保证性能下限</strong>，在真实 DOM 操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。</p><p>在整个 DOM 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验/研发效率。 虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。<br><code>虚拟 DOM</code> 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。<br> 虚拟 DOM 的优越之处在于，它能够在<strong>提供更爽、更高效的研发模式</strong>（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。</p><h2 id="_5-react-与-vue-的-diff-算法有何不同" tabindex="-1"><a class="header-anchor" href="#_5-react-与-vue-的-diff-算法有何不同" aria-hidden="true">#</a> 5. React 与 Vue 的 diff 算法有何不同？</h2><p>diff 算法是指<code>生成更新补丁的方式</code>，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：<strong>触发更新 → 生成补丁 → 应用补丁</strong>。</p><p>React 的 diff 算法，触发更新的<strong>时机</strong>主要在 <code>state</code> 变化与 <code>hooks</code> 调用之后。此时触发虚拟 DOM 树变更遍历，采用了<strong>深度优先遍历算法</strong>。但传统的遍历方式，效率较低。为了优化效率，使用了<strong>分治</strong>的方式。<br> 将单一节点比对转化为了 3 种类型节点的比对，分别是<code>树、组件及元素</code>，以此提升效率。</p><ul><li>树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。</li><li>组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。</li><li>元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。 以上是经典的 React diff 算法内容。<br> 自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 <code>FiberNode</code> 与 <code>FiberTree</code> 进行重构。fiberNode 使用了<strong>双链表</strong>的结构，可以直接找到兄弟节点与子节点。 整个更新过程由 <code>current</code> 与 <code>workInProgress</code> 两株树<strong>双缓冲</strong>完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。</li></ul><p>Vue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。</p>`,35),d=[p];function i(l,r){return a(),s("div",null,d)}const k=n(c,[["render",i],["__file","react_virtual_dom.html.vue"]]);export{k as default};
