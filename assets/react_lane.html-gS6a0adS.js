import{_ as t,r as p,o,c,a as n,d as s,b as e,e as i}from"./app-lzSeYDl-.js";const l={},u=n("h1",{id:"react-设计原理-lane-模型-🎉",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#react-设计原理-lane-模型-🎉","aria-hidden":"true"},"#"),s(" React 设计原理：Lane 模型 🎉")],-1),r={id:"lanu-模型",tabindex:"-1"},d=n("a",{class:"header-anchor",href:"#lanu-模型","aria-hidden":"true"},"#",-1),k={href:"https://juejin.cn/post/7248982532728602681",target:"_blank",rel:"noopener noreferrer"},v=n("p",null,[s("React 的 "),n("code",null,"fiber"),s(" 架构最重要的功能，就是"),n("strong",null,"可中断式递归组件"),s("根据状态优先级更新页面。那么 React 是怎么确定优先级的呢？")],-1),b={href:"https://juejin.cn/post/7248982532728602681",target:"_blank",rel:"noopener noreferrer"},m=i(`<div class="custom-container warning"><p class="custom-container-title">WARNING</p><p><code>expressTime</code> 被抛弃了</p></div><h3 id="lanu-模型思想" tabindex="-1"><a class="header-anchor" href="#lanu-模型思想" aria-hidden="true">#</a> Lanu 模型思想</h3><p><code>Lane</code> 模型是 React 中的一种状态更新机制，它的核心思想是<strong>将 UI 中的状态变化抽象成一系列的 “lane”（变化）</strong>，每个 “lane” 只描述了一个状态的变化，而不是一次完整的状态更新。这样可以使得状态变化更加清晰，易于处理和维护。</p><p>举个例子，假设我们有一个计数器组件，它包含一个按钮和一个文本框，点击按钮会将文本框中的值加一。我们可以使用 Lane 模型来拆分状态变化，将状态变化分为两个小的状态变化：</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 更新方式 1</span>
<span class="token keyword">function</span> <span class="token function">handleClick1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 更新方式 2</span>
<span class="token keyword">function</span> <span class="token function">handleClick2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevCount<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> prevCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更新方式 1 中，<code>setCount</code> 更新的是一个计算表达式的结果，所以无法识别它的具体含义。</p><p>更新方式 2 则将状态更新拆分成了两个小的状态变化：</p><ol><li>获取当前的 <code>count</code> 值，即 <code>prevCount</code>。</li><li>将 <code>prevCount</code> 的值加一，得到新的 count 值</li></ol><p>这种更新方式更加精准，因为 React 可以正确地识别状态变化，并将其拆分成多个小的状态变化。</p><p>我们来看下如下的例子：</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">onClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">onAsyncClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">add</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onAsyncClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">async add</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在点击 <code>async add</code> 按钮的 2 秒内，我们点击 <code>add</code> 按钮两次，<code>count</code> 先由 <code>0</code> 变为 <code>2</code>，2 秒后，又变为 <code>1</code> 了。</p><p>如果我们采用下面的方式更新状态</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">onAsyncClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">=&gt;</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><div class="highlight-line"> </div><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么 2 秒后，则会按预期一样，更新为 <code>3</code>。</p><h3 id="lane-模型原理" tabindex="-1"><a class="header-anchor" href="#lane-模型原理" aria-hidden="true">#</a> Lane 模型原理</h3><p>在 React 中，Lane 模型是一种<strong>用于调度更新任务的机制</strong>，其目的是提高应用的性能和响应速度。React 中涉及的 Lane 主要有以下几种：</p><ul><li><p><strong>SyncLane</strong>：同步更新 Lane，用于处理需要立即得到执行的更新任务，例如由 <code>ReactDom.render()</code> 或 <code>ReactDOMServer.renderToString()</code> 触发的更新任务。</p></li><li><p><strong>InputContinuousLane</strong>：连续</p></li><li><p><strong>DefaultLane</strong>：默认 Lane，用于处理普通的更新任务，例如由 <code>useEffect()</code> 或 <code>useLayoutEffect()</code> 触发的更新任务。</p></li><li><p><strong>IdleLane</strong>：空闲<code> Lane</code>，用于处理空闲时需要执行的更新任务，例如预加载图片等。</p><p>Lane 的具体值为 <code>32</code> 位数字，</p></li></ul><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> SyncLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token operator">/</span>\\<span class="token operator">*</span> _<span class="token operator">/</span> <span class="token number">0b0000000000000000000000000000010</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> IdleLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token operator">/</span>_ _<span class="token operator">/</span> <span class="token number">0b0100000000000000000000000000000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> InputContinuousLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token operator">/</span>_ _<span class="token operator">/</span> <span class="token number">0b0000000000000000000000000001000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> DefaultLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token operator">/</span>_ \\<span class="token operator">*</span><span class="token operator">/</span> <span class="token number">0b0000000000000000000000000100000</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些 Lane 的优先级顺序依次降低，<code>SyncLane</code> 的优先级最高，<code>IdleLane</code> 的优先级最低。</p><p>而在 React 源码中，相关的 <code>EventPriority</code> 定义在 <code>ReactEventPriorities.js</code> 文件中，其定义如下：</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> DiscreteEventPriority <span class="token operator">=</span> SyncLane<span class="token punctuation">;</span>
<span class="token keyword">const</span> ContinuousEventPriority <span class="token operator">=</span> InputContinuousLane<span class="token punctuation">;</span>
<span class="token keyword">const</span> DefaultEventPriority <span class="token operator">=</span> DefaultLane<span class="token punctuation">;</span>
<span class="token keyword">const</span> IdleEventPriority <span class="token operator">=</span> IdleLane<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以下是<strong>四个事件优先级</strong>：</p><ul><li><p><strong>离散事件（DiscreteEvent）</strong>：指需要立即执行的事件，例如输入框的 onChange 事件。这些事件需要立即得到响应，以保证应用的交互性能。</p></li><li><p><strong>用户交互事件（UserBlockingEvent）</strong>：指与用户交互相关的事件，例如点击、滚动等。这些事件也需要尽快得到响应，以提供流畅的用户体验。</p></li><li><p><strong>普通事件（NormalEvent）</strong>：指一般的更新事件，例如数据更新、网络请求等。这些事件的优先级较低，可以等待一段时间再执行。</p></li><li><p><strong>空闲事件（IdleEvent）</strong>：指可以在浏览器空闲时执行的事件，例如预加载图片等。这些事件的优先级最低，只有在没有其他任务需要执行时才会执行。</p><p>首先，React 每次更新状态会将同类型的 Lane 合并形成 <code>Lanes</code>，然后从同类型的 <code>Lanes</code> 中找出优先级最高的事件。</p></li></ul><p>这里有两个问题：</p><ul><li>Lane 是如何合并成 Lanes 的？</li><li>怎么从 Lanes 中找出优先级最高的？</li></ul><p>首先，React 通过位运算 <code>lane &amp; lane</code> 判断两个 lane 是否是同一类型，如果是，再使用 <code>lane | lane</code> 将 lane 合并成 lanes。</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">function</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">|</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">intersectLanes</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
queueLanes <span class="token operator">=</span> <span class="token function">intersectLanes</span><span class="token punctuation">(</span>queueLanes<span class="token punctuation">,</span> root<span class="token punctuation">.</span>pendingLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newQueueLanes <span class="token operator">=</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>queueLanes<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span>lanes <span class="token operator">=</span> newQueueLanes<span class="token punctuation">;</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><div class="highlight-line"> </div><br><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要更新状态时，使用 <code>lanes &amp; -lanes</code> 从相同的 lanes 中找出优先级最高的 lane</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">function</span> <span class="token function">getHighestPriorityLane</span><span class="token punctuation">(</span>lanes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> lanes <span class="token operator">&amp;</span> <span class="token operator">-</span>lanes<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后将这个 lane 转为对应的 <code>EventPriority</code>。</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">function</span> <span class="token function">lanesToEventPriority</span><span class="token punctuation">(</span>lanes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> lane <span class="token operator">=</span> <span class="token function">getHighestPriorityLane</span><span class="token punctuation">(</span>lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHigherEventPriority</span><span class="token punctuation">(</span>DiscreteEventPriority<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> DiscreteEventPriority<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHigherEventPriority</span><span class="token punctuation">(</span>ContinuousEventPriority<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ContinuousEventPriority<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">includesNonIdleWork</span><span class="token punctuation">(</span>lane<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> DefaultEventPriority<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> IdleEventPriority<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><div class="highlight-line"> </div><br><br><br><div class="highlight-line"> </div><br><br><br><div class="highlight-line"> </div><br><br><br><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当事件需要处理时，React 总会将优先级最高的事件交给 <code>Scheduler</code> （<strong>调度包</strong>）转换为更新任务，并将其加入任务队列中。任务队列中的任务按照事件优先级从高到低排序，以确保高优先级任务优先执行。</p><p>再 <code>Scheduler</code> 中又会<strong>将 <code>EventPriority</code> 优先级转换为任务优先级</strong>。然后根据任务优先级进行排序。</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">let</span> schedulerPriorityLevel<span class="token punctuation">;</span>

<span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token function">lanesToEventPriority</span><span class="token punctuation">(</span>nextLanes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> DiscreteEventPriority<span class="token operator">:</span>
schedulerPriorityLevel <span class="token operator">=</span> ImmediatePriority<span class="token punctuation">;</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>

<span class="token keyword">case</span> ContinuousEventPriority<span class="token operator">:</span>
schedulerPriorityLevel <span class="token operator">=</span> UserBlockingPriority<span class="token punctuation">;</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>

<span class="token keyword">case</span> DefaultEventPriority<span class="token operator">:</span>
schedulerPriorityLevel <span class="token operator">=</span> NormalPriority<span class="token punctuation">;</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>

<span class="token keyword">case</span> IdleEventPriority<span class="token operator">:</span>
schedulerPriorityLevel <span class="token operator">=</span> IdlePriority<span class="token punctuation">;</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>

<span class="token keyword">default</span><span class="token operator">:</span>
schedulerPriorityLevel <span class="token operator">=</span> NormalPriority<span class="token punctuation">;</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>任务优先级和 <code>EventPriority</code> 优先级对应该关系也如上面代码 switch 的对应关系。</p><h3 id="位运算原理" tabindex="-1"><a class="header-anchor" href="#位运算原理" aria-hidden="true">#</a> 位运算原理</h3><p>在 JavaScript 中，位运算是一种操作二进制数字的运算。它们利用数字的二进制表示来执行按位操作。以 3 和 5 为例，3 的二进制为 0011，5 的二进制为 0101，我们看如下的运算：</p><ul><li><strong>与运算（&amp;）</strong>：只有在两个数的对应位都为 1 时，结果的对应位才为 1，否则为 0。3 &amp; 5 的结果为 0001。</li><li><strong>或运算（|）</strong>：只有在两个数的对应位都为 0 时，结果的对应位才为 0，否则为 1。3 | 5 的结果为 0111。</li><li><strong>非运算（~）</strong>：将一个数的二进制位按位取反，即 0 变为 1，1 变为 0。~3 的结果为 1100</li></ul><p><strong>总结</strong></p><p>Lane 贯穿 React 更新的整个流程，是底层更新最重要的部分，本文讲述了 Lane 模型的原理以及再源码中的一些体现，后面的文章中我们会继续深入一些比较复杂的知识点，打通源码阅读的障碍。</p>`,41);function g(h,y){const a=p("ExternalLinkIcon");return o(),c("div",null,[u,n("h2",r,[d,s(),n("a",k,[s("Lanu 模型"),e(a)])]),v,n("p",null,[s("答案是 "),n("strong",null,[n("a",b,[s("Lane 模型（又称为 Fiber Lane）"),e(a)])]),s("，")]),m])}const L=t(l,[["render",g],["__file","react_lane.html.vue"]]);export{L as default};
