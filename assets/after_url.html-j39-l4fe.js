import{_ as i,r as t,o as a,c as r,a as e,d as c,b as d,e as l}from"./app-lzSeYDl-.js";const s={},n=l('<h1 id="面试官-说说地址栏输入-url-敲下回车后发生了什么" tabindex="-1"><a class="header-anchor" href="#面试官-说说地址栏输入-url-敲下回车后发生了什么" aria-hidden="true">#</a> 面试官：说说地址栏输入 URL 敲下回车后发生了什么?</h1><p><img src="https://static.vue-js.com/11bf1f20-bdf4-11eb-85f6-6fac77c0c9b3.png" alt="址栏输入 URL"></p><h2 id="一、简单分析" tabindex="-1"><a class="header-anchor" href="#一、简单分析" aria-hidden="true">#</a> 一、简单分析</h2><p>从前端的角度分析，从输入 <code>URL</code>到回车后发生的行为如下：</p><ul><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求</li><li>响应请求</li><li>页面渲染</li></ul><h2 id="二、详细分析" tabindex="-1"><a class="header-anchor" href="#二、详细分析" aria-hidden="true">#</a> 二、详细分析</h2><h3 id="url-解析" tabindex="-1"><a class="header-anchor" href="#url-解析" aria-hidden="true">#</a> URL 解析</h3><p>首先判断你输入的是一个合法的<code> URL</code> 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作</p><p><code>URL</code>的解析第过程中的第一步，一个<code>url</code>的结构解析如下：</p><p><img src="https://static.vue-js.com/27a0c690-bdf4-11eb-ab90-d9ae814b240d.png" alt=""></p><h3 id="dns-查询" tabindex="-1"><a class="header-anchor" href="#dns-查询" aria-hidden="true">#</a> DNS 查询</h3><p>将域名解析成 <code>IP</code> 地址</p><p>整个查询过程如下图所示：</p><p><img src="https://static.vue-js.com/330fb770-bdf4-11eb-85f6-6fac77c0c9b3.png" alt=""></p><p>最终，获取到了域名对应的目标服务器<code>IP</code>地址</p><h3 id="tcp-连接" tabindex="-1"><a class="header-anchor" href="#tcp-连接" aria-hidden="true">#</a> TCP 连接</h3><p>在之前文章中，了解到<code>tcp</code>是一种面向有连接的传输层协议</p><p>在确定目标服务器服务器的<code>IP</code>地址后，则经历三次握手建立<code>TCP</code>连接，流程如下：</p><p><img src="https://static.vue-js.com/ad750790-bdf4-11eb-85f6-6fac77c0c9b3.png" alt=""></p><h3 id="发送-http-请求" tabindex="-1"><a class="header-anchor" href="#发送-http-请求" aria-hidden="true">#</a> 发送 http 请求</h3><p>当建立<code>tcp</code>连接之后，就可以在这基础上进行通信，浏览器发送 <code>http</code> 请求到目标服务器</p><p>请求的内容包括：</p><ul><li>请求行</li><li>请求头</li><li>请求主体</li></ul><p><img src="https://static.vue-js.com/bbcb60f0-bdf4-11eb-ab90-d9ae814b240d.png" alt=""></p><h3 id="响应请求" tabindex="-1"><a class="header-anchor" href="#响应请求" aria-hidden="true">#</a> 响应请求</h3><p>当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个<code>HTTP</code>响应消息，包括：</p><ul><li>状态行</li><li>响应头</li><li>响应正文</li></ul><p><img src="https://static.vue-js.com/c5fe0140-bdf4-11eb-ab90-d9ae814b240d.png" alt="响应请求"></p><p>在服务器响应之后，由于现在<code>http</code>默认开始长连接<code>keep-alive</code>，当页面关闭之后，<code>tcp</code>链接则会经过四次挥手完成断开</p><h3 id="页面渲染" tabindex="-1"><a class="header-anchor" href="#页面渲染" aria-hidden="true">#</a> 页面渲染</h3><p>当浏览器接收到服务器响应的资源后，首先会对资源进行解析：</p><ul><li>查看响应头的信息，根据不同的指示做对应处理，比如<strong>重定向</strong>，存储 <code>cookie</code>，<strong>解压 gzip</strong>，<strong>缓存资源</strong>等等</li><li>查看响应头的 <code>Content-Type</code> 的值，根据不同的资源类型采用不同的解析方式</li></ul><p>关于页面的渲染过程如下：</p><p>浏览器接收到首屏 html，开始渲染</p><ul><li>解析 <code>HTML</code>，构建 <code>DOM</code> 树</li><li>解析 <code>CSS</code> ，生成 <code>CSS</code> 规则树</li><li>合并 <code>DOM</code> 树和 <code>CSS</code> 规则，生成 <code>render</code> 树</li><li>布局 <code>render</code> 树（ <code>Layout</code> / <code>reflow</code> ），负责各元素尺寸、位置的计算</li><li>绘制 <code>render</code> 树（ <code>paint</code> ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 <code>GPU</code>，<code>GPU</code> 会将各层合成（ <code>composite</code> ），显示在屏幕上</li></ul><p><img src="https://static.vue-js.com/db7bddd0-bdf4-11eb-85f6-6fac77c0c9b3.png" alt="页面渲染"></p><p>从上面步骤可以看出，影响性能的主要是<code>加载</code>和<code>渲染</code>。此外还有运行时的性能：<code>脚本执行</code>。</p><h2 id="加载优化" tabindex="-1"><a class="header-anchor" href="#加载优化" aria-hidden="true">#</a> 加载优化</h2><p>资源加载（网络层面）方面的性能优化主要是 <strong><em>减小资源体积，减少请求数量</em></strong></p><h3 id="减小资源体积" tabindex="-1"><a class="header-anchor" href="#减小资源体积" aria-hidden="true">#</a> 减小资源体积</h3><p>减小资源体积最有效的方法就是压缩。比如 js 混淆压缩，html 压缩，图片压缩等。再加上 Gzip 神器，再压缩三分之一以上不是问题</p><ul><li>实际项目中体积大的基本上是图片，字体这些资源，代码体积反而没那么大 <ul><li>注意 <strong><em>图片格式</em></strong>，png 格式无损压缩</li><li><strong>字体的优化</strong>，在一些场景下，可以直接抽出需要的字体，文件立马小很多</li><li><strong><em>按需加载</em></strong>，在组件库、babel-polyfill 等场景应用比较多</li></ul></li></ul><h3 id="减少请求数量" tabindex="-1"><a class="header-anchor" href="#减少请求数量" aria-hidden="true">#</a> 减少请求数量</h3><p>减少请求数量，常用的方法就是 **<em>缓存</em>**和 <strong><em>合并请求</em></strong></p><ul><li>效果最顶的就是<strong>浏览器缓存</strong>。通过 <code>expires</code> 和 <code>Cache-Control</code> 进行<strong>强缓存</strong>；通过 <code>Last-Modified</code> 和 <code>ETag</code> 进行<strong>协商缓存</strong>，就能缓存大部分资源文件。基本上就剩文档（html）和接口的请求了。</li><li>第二种缓存是 <code>CDN</code>。<code>CDN</code> 是一组分布在各个地区的服务器，它们会缓存资源副本。用户发起请求时，哪个服务器近就由其响应请求。一般存放不需要服务端进行计算，且具有访问频率高，承载流量大的资源，如图片，脚本，样式文件等静态资源。</li><li>合并请求的方案就比较多了。如针对小图标的 <code>CSS sprite</code>、<code>base64</code>、<code>iconfont</code> 等；通过 <code>webpack</code> 等工具将 <code>js</code>、<code>css</code> <strong>打包</strong>成一个文件。但请求不是越少越好，一个大请求的速度不一定快过几个小请求，浏览器能同时发起几个请求，要充分利用这一特点。</li><li>减少请求数量还有 <strong><em>懒加载</em></strong> 和 <strong><em>预加载</em></strong> 的方法。<strong>懒加载</strong> 可以减少首屏的请求数量，如 <code>import()</code>。预加载则可以提高后续的用户体验，如预解析 <code>dns-prefetch</code>，预拉取 <code>prefetch</code>，图片预加载等。<strong><em>懒加载和预加载并不冲突</em></strong>，可以理解为不是马上需要的内容可以懒加载，即将需要的内容可以在浏览器空闲的时候预先加载。</li></ul><h3 id="渲染优化" tabindex="-1"><a class="header-anchor" href="#渲染优化" aria-hidden="true">#</a> 渲染优化</h3><ul><li>提到渲染优化就不得不提 <strong>回流和重绘</strong>。批量操作 <code>DOM</code>，动画脱离文档流，<code>requestAnimationFrame</code> 这些方法就不多说了，容易忽略的是获取 <code>offsetLeft</code>， <code>offsetTop</code> 等值的时候也可能引起回流。由于回流成本太高，<strong><em>浏览器会将回流操作用队列存储</em></strong>，当过一段时间或达到某个阈值时清空队列，执行一次回流。但当获取有些值时，浏览器会提前触发回流，以确保获取的值是正确的。</li><li>其次是**<em>非阻塞</em>**。js 文件放 body 底部；<code>&lt;script&gt;</code> 标签的 <code>async</code> 和 <code>defer</code> 属性也是大家熟悉的。</li><li>除此之外，还有针对首屏渲染优化的 <strong><em>服务端渲染 SSR</em></strong>，优化首屏体验的 <strong><em>骨架屏</em></strong> 方案，针对长列表优化的<strong>虚拟列表</strong>等</li></ul><h3 id="js-代码" tabindex="-1"><a class="header-anchor" href="#js-代码" aria-hidden="true">#</a> js 代码</h3><p>代码层面的优化可以说道的很多，但实际上对性能影响很小，可以说是积少成多。除非写出天怒人怨的代码。以下举几个例子：</p><ul><li><p>保存深层变量</p></li><li><p>使用 <code>===</code> 而非<code>==</code>，避免类型转换带来的性能损耗</p></li><li><p>少用 <code>for-in</code></p></li><li><p>使用 <code>if-else</code>、<code>switch</code> 时，将最可能出现的情况放到前面</p></li><li><p>当条件大于（等于）3 个时，使用 <code>switch</code>。而当要判断的离散值数量很大时，使用对象或数据实现查表法</p></li><li><p>尾递归</p></li><li><p>避免改变词法作用域（如 <code>eval</code>，<code>with</code>）</p></li><li><p>减少操作 <code>DOM</code></p></li><li><p>事件委托</p></li><li><p>删除 <code>DOM</code> 节点时，移除其绑定的事件</p></li><li><p>用 JS 实现动画时，应使用 <code>requestAnimationFrame</code></p></li><li><p>防抖和节流</p></li><li><p><code>web worker</code></p><p>在使用框架时，还有针对框架的优化。如 Vue 中 <code>v-for</code> 循环 <code>key</code> 的绑定，<code>Object.freeze</code> 取消不会变更的数据的监听，切分成更小的组件以缩小更新的范围等。以及 React 中 <code>useMemo</code>，<code>useCallback</code> 等缓存钩子的使用</p></li></ul><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h2>',51),p={href:"https://github.com/febobo/web-interview/issues/141",target:"_blank",rel:"noopener noreferrer"},h={href:"https://zhuanlan.zhihu.com/p/80551769",target:"_blank",rel:"noopener noreferrer"};function u(f,b){const o=t("ExternalLinkIcon");return a(),r("div",null,[n,e("ul",null,[e("li",null,[e("a",p,[c("https://github.com/febobo/web-interview/issues/141"),d(o)])]),e("li",null,[e("a",h,[c("https://zhuanlan.zhihu.com/p/80551769"),d(o)])])])])}const m=i(s,[["render",u],["__file","after_url.html.vue"]]);export{m as default};
